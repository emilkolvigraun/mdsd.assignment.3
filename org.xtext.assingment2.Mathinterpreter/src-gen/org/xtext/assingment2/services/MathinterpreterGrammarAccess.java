/*
 * generated by Xtext 2.21.0
 */
package org.xtext.assingment2.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class MathinterpreterGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.assingment2.Mathinterpreter.Model");
		private final Assignment cMathexpressionAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cMathexpressionMathExpressionParserRuleCall_0 = (RuleCall)cMathexpressionAssignment.eContents().get(0);
		
		//Model:
		//	mathexpression+=MathExpression*;
		@Override public ParserRule getRule() { return rule; }
		
		//mathexpression+=MathExpression*
		public Assignment getMathexpressionAssignment() { return cMathexpressionAssignment; }
		
		//MathExpression
		public RuleCall getMathexpressionMathExpressionParserRuleCall_0() { return cMathexpressionMathExpressionParserRuleCall_0; }
	}
	public class MathExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.assingment2.Mathinterpreter.MathExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFunctionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDefineExprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//MathExpression:
		//	Function | DefineExpr;
		@Override public ParserRule getRule() { return rule; }
		
		//Function | DefineExpr
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Function
		public RuleCall getFunctionParserRuleCall_0() { return cFunctionParserRuleCall_0; }
		
		//DefineExpr
		public RuleCall getDefineExprParserRuleCall_1() { return cDefineExprParserRuleCall_1; }
	}
	public class FunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.assingment2.Mathinterpreter.Function");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cResultKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDescriptionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_1_0 = (RuleCall)cDescriptionAssignment_1.eContents().get(0);
		private final Keyword cIsKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpressionPMExpressionParserRuleCall_3_0 = (RuleCall)cExpressionAssignment_3.eContents().get(0);
		
		//Function:
		//	'result' description=STRING 'is' expression=PMExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//'result' description=STRING 'is' expression=PMExpression
		public Group getGroup() { return cGroup; }
		
		//'result'
		public Keyword getResultKeyword_0() { return cResultKeyword_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_1() { return cDescriptionAssignment_1; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_1_0() { return cDescriptionSTRINGTerminalRuleCall_1_0; }
		
		//'is'
		public Keyword getIsKeyword_2() { return cIsKeyword_2; }
		
		//expression=PMExpression
		public Assignment getExpressionAssignment_3() { return cExpressionAssignment_3; }
		
		//PMExpression
		public RuleCall getExpressionPMExpressionParserRuleCall_3_0() { return cExpressionPMExpressionParserRuleCall_3_0; }
	}
	public class DefineExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.assingment2.Mathinterpreter.DefineExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cDescriptionAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_0_0_0 = (RuleCall)cDescriptionAssignment_0_0.eContents().get(0);
		private final Keyword cAsKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Keyword cLetKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cVariablesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVariablesVariableParserRuleCall_2_0 = (RuleCall)cVariablesAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cAndKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cVariablesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cVariablesVariableParserRuleCall_3_1_0 = (RuleCall)cVariablesAssignment_3_1.eContents().get(0);
		private final Keyword cInKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cExpressionAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cExpressionPMExpressionParserRuleCall_5_0 = (RuleCall)cExpressionAssignment_5.eContents().get(0);
		private final Keyword cEndKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//DefineExpr:
		//	(description=STRING 'as')? 'let' variables+=Variable ('and' variables+=Variable)* 'in' expression=PMExpression 'end';
		@Override public ParserRule getRule() { return rule; }
		
		//(description=STRING 'as')? 'let' variables+=Variable ('and' variables+=Variable)* 'in' expression=PMExpression 'end'
		public Group getGroup() { return cGroup; }
		
		//(description=STRING 'as')?
		public Group getGroup_0() { return cGroup_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_0_0() { return cDescriptionAssignment_0_0; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_0_0_0() { return cDescriptionSTRINGTerminalRuleCall_0_0_0; }
		
		//'as'
		public Keyword getAsKeyword_0_1() { return cAsKeyword_0_1; }
		
		//'let'
		public Keyword getLetKeyword_1() { return cLetKeyword_1; }
		
		//variables+=Variable
		public Assignment getVariablesAssignment_2() { return cVariablesAssignment_2; }
		
		//Variable
		public RuleCall getVariablesVariableParserRuleCall_2_0() { return cVariablesVariableParserRuleCall_2_0; }
		
		//('and' variables+=Variable)*
		public Group getGroup_3() { return cGroup_3; }
		
		//'and'
		public Keyword getAndKeyword_3_0() { return cAndKeyword_3_0; }
		
		//variables+=Variable
		public Assignment getVariablesAssignment_3_1() { return cVariablesAssignment_3_1; }
		
		//Variable
		public RuleCall getVariablesVariableParserRuleCall_3_1_0() { return cVariablesVariableParserRuleCall_3_1_0; }
		
		//'in'
		public Keyword getInKeyword_4() { return cInKeyword_4; }
		
		//expression=PMExpression
		public Assignment getExpressionAssignment_5() { return cExpressionAssignment_5; }
		
		//PMExpression
		public RuleCall getExpressionPMExpressionParserRuleCall_5_0() { return cExpressionPMExpressionParserRuleCall_5_0; }
		
		//'end'
		public Keyword getEndKeyword_6() { return cEndKeyword_6; }
	}
	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.assingment2.Mathinterpreter.Variable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionPMExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		
		//Variable:
		//	name=ID '=' expression=PMExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID '=' expression=PMExpression
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }
		
		//expression=PMExpression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }
		
		//PMExpression
		public RuleCall getExpressionPMExpressionParserRuleCall_2_0() { return cExpressionPMExpressionParserRuleCall_2_0; }
	}
	public class ExternalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.assingment2.Mathinterpreter.External");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExternalKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cArgumentsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Alternatives cArgumentsAlternatives_3_0 = (Alternatives)cArgumentsAssignment_3.eContents().get(0);
		private final RuleCall cArgumentsVariableNameParserRuleCall_3_0_0 = (RuleCall)cArgumentsAlternatives_3_0.eContents().get(0);
		private final RuleCall cArgumentsNumberParserRuleCall_3_0_1 = (RuleCall)cArgumentsAlternatives_3_0.eContents().get(1);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cCommaKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cArgumentsAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final Alternatives cArgumentsAlternatives_4_1_0 = (Alternatives)cArgumentsAssignment_4_1.eContents().get(0);
		private final RuleCall cArgumentsVariableNameParserRuleCall_4_1_0_0 = (RuleCall)cArgumentsAlternatives_4_1_0.eContents().get(0);
		private final RuleCall cArgumentsNumberParserRuleCall_4_1_0_1 = (RuleCall)cArgumentsAlternatives_4_1_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//External:
		//	'external.' name=ID '(' arguments+=(VariableName | Number) (',' arguments+=(VariableName | Number))* ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'external.' name=ID '(' arguments+=(VariableName | Number) (',' arguments+=(VariableName | Number))* ')'
		public Group getGroup() { return cGroup; }
		
		//'external.'
		public Keyword getExternalKeyword_0() { return cExternalKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//arguments+=(VariableName | Number)
		public Assignment getArgumentsAssignment_3() { return cArgumentsAssignment_3; }
		
		//(VariableName | Number)
		public Alternatives getArgumentsAlternatives_3_0() { return cArgumentsAlternatives_3_0; }
		
		//VariableName
		public RuleCall getArgumentsVariableNameParserRuleCall_3_0_0() { return cArgumentsVariableNameParserRuleCall_3_0_0; }
		
		//Number
		public RuleCall getArgumentsNumberParserRuleCall_3_0_1() { return cArgumentsNumberParserRuleCall_3_0_1; }
		
		//(',' arguments+=(VariableName | Number))*
		public Group getGroup_4() { return cGroup_4; }
		
		//','
		public Keyword getCommaKeyword_4_0() { return cCommaKeyword_4_0; }
		
		//arguments+=(VariableName | Number)
		public Assignment getArgumentsAssignment_4_1() { return cArgumentsAssignment_4_1; }
		
		//(VariableName | Number)
		public Alternatives getArgumentsAlternatives_4_1_0() { return cArgumentsAlternatives_4_1_0; }
		
		//VariableName
		public RuleCall getArgumentsVariableNameParserRuleCall_4_1_0_0() { return cArgumentsVariableNameParserRuleCall_4_1_0_0; }
		
		//Number
		public RuleCall getArgumentsNumberParserRuleCall_4_1_0_1() { return cArgumentsNumberParserRuleCall_4_1_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class PMExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.assingment2.Mathinterpreter.PMExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMDExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPMExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorPlusMinusParserRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMDExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//PMExpression:
		//	MDExpression ({PMExpression.left=current} operator=PlusMinus right=MDExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//MDExpression ({PMExpression.left=current} operator=PlusMinus right=MDExpression)*
		public Group getGroup() { return cGroup; }
		
		//MDExpression
		public RuleCall getMDExpressionParserRuleCall_0() { return cMDExpressionParserRuleCall_0; }
		
		//({PMExpression.left=current} operator=PlusMinus right=MDExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{PMExpression.left=current}
		public Action getPMExpressionLeftAction_1_0() { return cPMExpressionLeftAction_1_0; }
		
		//operator=PlusMinus
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }
		
		//PlusMinus
		public RuleCall getOperatorPlusMinusParserRuleCall_1_1_0() { return cOperatorPlusMinusParserRuleCall_1_1_0; }
		
		//right=MDExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//MDExpression
		public RuleCall getRightMDExpressionParserRuleCall_1_2_0() { return cRightMDExpressionParserRuleCall_1_2_0; }
	}
	public class MDExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.assingment2.Mathinterpreter.MDExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPowExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMDExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorMultiplyDivideParserRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPowExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//MDExpression:
		//	PowExpression ({MDExpression.left=current} operator=MultiplyDivide right=PowExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//PowExpression ({MDExpression.left=current} operator=MultiplyDivide right=PowExpression)*
		public Group getGroup() { return cGroup; }
		
		//PowExpression
		public RuleCall getPowExpressionParserRuleCall_0() { return cPowExpressionParserRuleCall_0; }
		
		//({MDExpression.left=current} operator=MultiplyDivide right=PowExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{MDExpression.left=current}
		public Action getMDExpressionLeftAction_1_0() { return cMDExpressionLeftAction_1_0; }
		
		//operator=MultiplyDivide
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }
		
		//MultiplyDivide
		public RuleCall getOperatorMultiplyDivideParserRuleCall_1_1_0() { return cOperatorMultiplyDivideParserRuleCall_1_1_0; }
		
		//right=PowExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//PowExpression
		public RuleCall getRightPowExpressionParserRuleCall_1_2_0() { return cRightPowExpressionParserRuleCall_1_2_0; }
	}
	public class PowExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.assingment2.Mathinterpreter.PowExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPowExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorPowerParserRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPrimaryParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//PowExpression:
		//	Primary ({PowExpression.left=current} operator=Power right=Primary)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Primary ({PowExpression.left=current} operator=Power right=Primary)*
		public Group getGroup() { return cGroup; }
		
		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }
		
		//({PowExpression.left=current} operator=Power right=Primary)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{PowExpression.left=current}
		public Action getPowExpressionLeftAction_1_0() { return cPowExpressionLeftAction_1_0; }
		
		//operator=Power
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }
		
		//Power
		public RuleCall getOperatorPowerParserRuleCall_1_1_0() { return cOperatorPowerParserRuleCall_1_1_0; }
		
		//right=Primary
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Primary
		public RuleCall getRightPrimaryParserRuleCall_1_2_0() { return cRightPrimaryParserRuleCall_1_2_0; }
	}
	public class PowerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.assingment2.Mathinterpreter.Power");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPowAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cAsteriskAsteriskKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Power:
		//	{Pow} '**';
		@Override public ParserRule getRule() { return rule; }
		
		//{Pow} '**'
		public Group getGroup() { return cGroup; }
		
		//{Pow}
		public Action getPowAction_0() { return cPowAction_0; }
		
		//'**'
		public Keyword getAsteriskAsteriskKeyword_1() { return cAsteriskAsteriskKeyword_1; }
	}
	public class PlusMinusElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.assingment2.Mathinterpreter.PlusMinus");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cPlusAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cPlusSignKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cMinusAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//PlusMinus:
		//	{Plus} '+' | {Minus} '-';
		@Override public ParserRule getRule() { return rule; }
		
		//{Plus} '+' | {Minus} '-'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{Plus} '+'
		public Group getGroup_0() { return cGroup_0; }
		
		//{Plus}
		public Action getPlusAction_0_0() { return cPlusAction_0_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_0_1() { return cPlusSignKeyword_0_1; }
		
		//{Minus} '-'
		public Group getGroup_1() { return cGroup_1; }
		
		//{Minus}
		public Action getMinusAction_1_0() { return cMinusAction_1_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1_1() { return cHyphenMinusKeyword_1_1; }
	}
	public class MultiplyDivideElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.assingment2.Mathinterpreter.MultiplyDivide");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cMultiplyAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cAsteriskKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cDivideAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//MultiplyDivide:
		//	{Multiply} '*' | {Divide} '/';
		@Override public ParserRule getRule() { return rule; }
		
		//{Multiply} '*' | {Divide} '/'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{Multiply} '*'
		public Group getGroup_0() { return cGroup_0; }
		
		//{Multiply}
		public Action getMultiplyAction_0_0() { return cMultiplyAction_0_0; }
		
		//'*'
		public Keyword getAsteriskKeyword_0_1() { return cAsteriskKeyword_0_1; }
		
		//{Divide} '/'
		public Group getGroup_1() { return cGroup_1; }
		
		//{Divide}
		public Action getDivideAction_1_0() { return cDivideAction_1_0; }
		
		//'/'
		public Keyword getSolidusKeyword_1_1() { return cSolidusKeyword_1_1; }
	}
	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.assingment2.Mathinterpreter.Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNumberParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVariableNameParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cPMParenthesisParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cDefParenthesisParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cExternalParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//Primary:
		//	Number | VariableName | PMParenthesis | DefParenthesis | External;
		@Override public ParserRule getRule() { return rule; }
		
		//Number | VariableName | PMParenthesis | DefParenthesis | External
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Number
		public RuleCall getNumberParserRuleCall_0() { return cNumberParserRuleCall_0; }
		
		//VariableName
		public RuleCall getVariableNameParserRuleCall_1() { return cVariableNameParserRuleCall_1; }
		
		//PMParenthesis
		public RuleCall getPMParenthesisParserRuleCall_2() { return cPMParenthesisParserRuleCall_2; }
		
		//DefParenthesis
		public RuleCall getDefParenthesisParserRuleCall_3() { return cDefParenthesisParserRuleCall_3; }
		
		//External
		public RuleCall getExternalParserRuleCall_4() { return cExternalParserRuleCall_4; }
	}
	public class VariableNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.assingment2.Mathinterpreter.VariableName");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//VariableName:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class NumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.assingment2.Mathinterpreter.Number");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPositiveParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNegativeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Number:
		//	Positive | Negative;
		@Override public ParserRule getRule() { return rule; }
		
		//Positive | Negative
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Positive
		public RuleCall getPositiveParserRuleCall_0() { return cPositiveParserRuleCall_0; }
		
		//Negative
		public RuleCall getNegativeParserRuleCall_1() { return cNegativeParserRuleCall_1; }
	}
	public class PositiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.assingment2.Mathinterpreter.Positive");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//Positive:
		//	value=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//value=INT
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//INT
		public RuleCall getValueINTTerminalRuleCall_0() { return cValueINTTerminalRuleCall_0; }
	}
	public class NegativeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.assingment2.Mathinterpreter.Negative");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//Negative:
		//	'-' value=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//'-' value=INT
		public Group getGroup() { return cGroup; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }
		
		//value=INT
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//INT
		public RuleCall getValueINTTerminalRuleCall_1_0() { return cValueINTTerminalRuleCall_1_0; }
	}
	public class PMParenthesisElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.assingment2.Mathinterpreter.PMParenthesis");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionPMExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//PMParenthesis:
		//	'(' expression=PMExpression ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' expression=PMExpression ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//expression=PMExpression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }
		
		//PMExpression
		public RuleCall getExpressionPMExpressionParserRuleCall_1_0() { return cExpressionPMExpressionParserRuleCall_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class DefParenthesisElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.assingment2.Mathinterpreter.DefParenthesis");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cDefineExprParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//DefParenthesis:
		//	'(' DefineExpr ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' DefineExpr ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//DefineExpr
		public RuleCall getDefineExprParserRuleCall_1() { return cDefineExprParserRuleCall_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	
	
	private final ModelElements pModel;
	private final MathExpressionElements pMathExpression;
	private final FunctionElements pFunction;
	private final DefineExprElements pDefineExpr;
	private final VariableElements pVariable;
	private final ExternalElements pExternal;
	private final PMExpressionElements pPMExpression;
	private final MDExpressionElements pMDExpression;
	private final PowExpressionElements pPowExpression;
	private final PowerElements pPower;
	private final PlusMinusElements pPlusMinus;
	private final MultiplyDivideElements pMultiplyDivide;
	private final PrimaryElements pPrimary;
	private final VariableNameElements pVariableName;
	private final NumberElements pNumber;
	private final PositiveElements pPositive;
	private final NegativeElements pNegative;
	private final PMParenthesisElements pPMParenthesis;
	private final DefParenthesisElements pDefParenthesis;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public MathinterpreterGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.pMathExpression = new MathExpressionElements();
		this.pFunction = new FunctionElements();
		this.pDefineExpr = new DefineExprElements();
		this.pVariable = new VariableElements();
		this.pExternal = new ExternalElements();
		this.pPMExpression = new PMExpressionElements();
		this.pMDExpression = new MDExpressionElements();
		this.pPowExpression = new PowExpressionElements();
		this.pPower = new PowerElements();
		this.pPlusMinus = new PlusMinusElements();
		this.pMultiplyDivide = new MultiplyDivideElements();
		this.pPrimary = new PrimaryElements();
		this.pVariableName = new VariableNameElements();
		this.pNumber = new NumberElements();
		this.pPositive = new PositiveElements();
		this.pNegative = new NegativeElements();
		this.pPMParenthesis = new PMParenthesisElements();
		this.pDefParenthesis = new DefParenthesisElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.assingment2.Mathinterpreter".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//	mathexpression+=MathExpression*;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	//MathExpression:
	//	Function | DefineExpr;
	public MathExpressionElements getMathExpressionAccess() {
		return pMathExpression;
	}
	
	public ParserRule getMathExpressionRule() {
		return getMathExpressionAccess().getRule();
	}
	
	//Function:
	//	'result' description=STRING 'is' expression=PMExpression;
	public FunctionElements getFunctionAccess() {
		return pFunction;
	}
	
	public ParserRule getFunctionRule() {
		return getFunctionAccess().getRule();
	}
	
	//DefineExpr:
	//	(description=STRING 'as')? 'let' variables+=Variable ('and' variables+=Variable)* 'in' expression=PMExpression 'end';
	public DefineExprElements getDefineExprAccess() {
		return pDefineExpr;
	}
	
	public ParserRule getDefineExprRule() {
		return getDefineExprAccess().getRule();
	}
	
	//Variable:
	//	name=ID '=' expression=PMExpression;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}
	
	//External:
	//	'external.' name=ID '(' arguments+=(VariableName | Number) (',' arguments+=(VariableName | Number))* ')';
	public ExternalElements getExternalAccess() {
		return pExternal;
	}
	
	public ParserRule getExternalRule() {
		return getExternalAccess().getRule();
	}
	
	//PMExpression:
	//	MDExpression ({PMExpression.left=current} operator=PlusMinus right=MDExpression)*;
	public PMExpressionElements getPMExpressionAccess() {
		return pPMExpression;
	}
	
	public ParserRule getPMExpressionRule() {
		return getPMExpressionAccess().getRule();
	}
	
	//MDExpression:
	//	PowExpression ({MDExpression.left=current} operator=MultiplyDivide right=PowExpression)*;
	public MDExpressionElements getMDExpressionAccess() {
		return pMDExpression;
	}
	
	public ParserRule getMDExpressionRule() {
		return getMDExpressionAccess().getRule();
	}
	
	//PowExpression:
	//	Primary ({PowExpression.left=current} operator=Power right=Primary)*;
	public PowExpressionElements getPowExpressionAccess() {
		return pPowExpression;
	}
	
	public ParserRule getPowExpressionRule() {
		return getPowExpressionAccess().getRule();
	}
	
	//Power:
	//	{Pow} '**';
	public PowerElements getPowerAccess() {
		return pPower;
	}
	
	public ParserRule getPowerRule() {
		return getPowerAccess().getRule();
	}
	
	//PlusMinus:
	//	{Plus} '+' | {Minus} '-';
	public PlusMinusElements getPlusMinusAccess() {
		return pPlusMinus;
	}
	
	public ParserRule getPlusMinusRule() {
		return getPlusMinusAccess().getRule();
	}
	
	//MultiplyDivide:
	//	{Multiply} '*' | {Divide} '/';
	public MultiplyDivideElements getMultiplyDivideAccess() {
		return pMultiplyDivide;
	}
	
	public ParserRule getMultiplyDivideRule() {
		return getMultiplyDivideAccess().getRule();
	}
	
	//Primary:
	//	Number | VariableName | PMParenthesis | DefParenthesis | External;
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}
	
	//VariableName:
	//	name=ID;
	public VariableNameElements getVariableNameAccess() {
		return pVariableName;
	}
	
	public ParserRule getVariableNameRule() {
		return getVariableNameAccess().getRule();
	}
	
	//Number:
	//	Positive | Negative;
	public NumberElements getNumberAccess() {
		return pNumber;
	}
	
	public ParserRule getNumberRule() {
		return getNumberAccess().getRule();
	}
	
	//Positive:
	//	value=INT;
	public PositiveElements getPositiveAccess() {
		return pPositive;
	}
	
	public ParserRule getPositiveRule() {
		return getPositiveAccess().getRule();
	}
	
	//Negative:
	//	'-' value=INT;
	public NegativeElements getNegativeAccess() {
		return pNegative;
	}
	
	public ParserRule getNegativeRule() {
		return getNegativeAccess().getRule();
	}
	
	//PMParenthesis:
	//	'(' expression=PMExpression ')';
	public PMParenthesisElements getPMParenthesisAccess() {
		return pPMParenthesis;
	}
	
	public ParserRule getPMParenthesisRule() {
		return getPMParenthesisAccess().getRule();
	}
	
	//DefParenthesis:
	//	'(' DefineExpr ')';
	public DefParenthesisElements getDefParenthesisAccess() {
		return pDefParenthesis;
	}
	
	public ParserRule getDefParenthesisRule() {
		return getDefParenthesisAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
