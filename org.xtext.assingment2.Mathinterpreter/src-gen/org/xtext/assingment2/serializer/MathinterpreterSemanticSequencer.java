/*
 * generated by Xtext 2.21.0
 */
package org.xtext.assingment2.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.assingment2.mathinterpreter.DefineExpr;
import org.xtext.assingment2.mathinterpreter.Divide;
import org.xtext.assingment2.mathinterpreter.External;
import org.xtext.assingment2.mathinterpreter.Function;
import org.xtext.assingment2.mathinterpreter.MDExpression;
import org.xtext.assingment2.mathinterpreter.MathinterpreterPackage;
import org.xtext.assingment2.mathinterpreter.Minus;
import org.xtext.assingment2.mathinterpreter.Model;
import org.xtext.assingment2.mathinterpreter.Multiply;
import org.xtext.assingment2.mathinterpreter.Negative;
import org.xtext.assingment2.mathinterpreter.PMExpression;
import org.xtext.assingment2.mathinterpreter.PMParenthesis;
import org.xtext.assingment2.mathinterpreter.Plus;
import org.xtext.assingment2.mathinterpreter.Positive;
import org.xtext.assingment2.mathinterpreter.Pow;
import org.xtext.assingment2.mathinterpreter.PowExpression;
import org.xtext.assingment2.mathinterpreter.Variable;
import org.xtext.assingment2.mathinterpreter.VariableName;
import org.xtext.assingment2.services.MathinterpreterGrammarAccess;

@SuppressWarnings("all")
public class MathinterpreterSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MathinterpreterGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MathinterpreterPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MathinterpreterPackage.DEFINE_EXPR:
				sequence_DefineExpr(context, (DefineExpr) semanticObject); 
				return; 
			case MathinterpreterPackage.DIVIDE:
				sequence_MultiplyDivide(context, (Divide) semanticObject); 
				return; 
			case MathinterpreterPackage.EXTERNAL:
				sequence_External(context, (External) semanticObject); 
				return; 
			case MathinterpreterPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case MathinterpreterPackage.MD_EXPRESSION:
				sequence_MDExpression(context, (MDExpression) semanticObject); 
				return; 
			case MathinterpreterPackage.MINUS:
				sequence_PlusMinus(context, (Minus) semanticObject); 
				return; 
			case MathinterpreterPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MathinterpreterPackage.MULTIPLY:
				sequence_MultiplyDivide(context, (Multiply) semanticObject); 
				return; 
			case MathinterpreterPackage.NEGATIVE:
				sequence_Negative(context, (Negative) semanticObject); 
				return; 
			case MathinterpreterPackage.PM_EXPRESSION:
				sequence_PMExpression(context, (PMExpression) semanticObject); 
				return; 
			case MathinterpreterPackage.PM_PARENTHESIS:
				sequence_PMParenthesis(context, (PMParenthesis) semanticObject); 
				return; 
			case MathinterpreterPackage.PLUS:
				sequence_PlusMinus(context, (Plus) semanticObject); 
				return; 
			case MathinterpreterPackage.POSITIVE:
				sequence_Positive(context, (Positive) semanticObject); 
				return; 
			case MathinterpreterPackage.POW:
				sequence_Power(context, (Pow) semanticObject); 
				return; 
			case MathinterpreterPackage.POW_EXPRESSION:
				sequence_PowExpression(context, (PowExpression) semanticObject); 
				return; 
			case MathinterpreterPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case MathinterpreterPackage.VARIABLE_NAME:
				sequence_VariableName(context, (VariableName) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     MathExpression returns DefineExpr
	 *     DefineExpr returns DefineExpr
	 *     PMExpression returns DefineExpr
	 *     PMExpression.PMExpression_1_0 returns DefineExpr
	 *     MDExpression returns DefineExpr
	 *     MDExpression.MDExpression_1_0 returns DefineExpr
	 *     PowExpression returns DefineExpr
	 *     PowExpression.PowExpression_1_0 returns DefineExpr
	 *     Primary returns DefineExpr
	 *     DefParenthesis returns DefineExpr
	 *
	 * Constraint:
	 *     (variables+=Variable variables+=Variable* (expression=PMExpression | expression=External))
	 */
	protected void sequence_DefineExpr(ISerializationContext context, DefineExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     External returns External
	 *
	 * Constraint:
	 *     (name=ID arguments+=Number arguments+=Number*)
	 */
	protected void sequence_External(ISerializationContext context, External semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MathExpression returns Function
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (description=STRING (expression=PMExpression | expression=External))
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PMExpression returns MDExpression
	 *     PMExpression.PMExpression_1_0 returns MDExpression
	 *     MDExpression returns MDExpression
	 *     MDExpression.MDExpression_1_0 returns MDExpression
	 *
	 * Constraint:
	 *     (left=MDExpression_MDExpression_1_0 operator=MultiplyDivide right=PowExpression)
	 */
	protected void sequence_MDExpression(ISerializationContext context, MDExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MathinterpreterPackage.Literals.PM_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathinterpreterPackage.Literals.PM_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MathinterpreterPackage.Literals.PM_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathinterpreterPackage.Literals.PM_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, MathinterpreterPackage.Literals.PM_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathinterpreterPackage.Literals.PM_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMDExpressionAccess().getMDExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMDExpressionAccess().getOperatorMultiplyDivideParserRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getMDExpressionAccess().getRightPowExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     mathexpression+=MathExpression+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultiplyDivide returns Divide
	 *
	 * Constraint:
	 *     {Divide}
	 */
	protected void sequence_MultiplyDivide(ISerializationContext context, Divide semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultiplyDivide returns Multiply
	 *
	 * Constraint:
	 *     {Multiply}
	 */
	protected void sequence_MultiplyDivide(ISerializationContext context, Multiply semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PMExpression returns Negative
	 *     PMExpression.PMExpression_1_0 returns Negative
	 *     MDExpression returns Negative
	 *     MDExpression.MDExpression_1_0 returns Negative
	 *     PowExpression returns Negative
	 *     PowExpression.PowExpression_1_0 returns Negative
	 *     Primary returns Negative
	 *     Number returns Negative
	 *     Negative returns Negative
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Negative(ISerializationContext context, Negative semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MathinterpreterPackage.Literals.NUMBER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathinterpreterPackage.Literals.NUMBER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNegativeAccess().getValueINTTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PMExpression returns PMExpression
	 *     PMExpression.PMExpression_1_0 returns PMExpression
	 *
	 * Constraint:
	 *     (left=PMExpression_PMExpression_1_0 operator=PlusMinus right=MDExpression)
	 */
	protected void sequence_PMExpression(ISerializationContext context, PMExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MathinterpreterPackage.Literals.PM_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathinterpreterPackage.Literals.PM_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MathinterpreterPackage.Literals.PM_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathinterpreterPackage.Literals.PM_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, MathinterpreterPackage.Literals.PM_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathinterpreterPackage.Literals.PM_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPMExpressionAccess().getPMExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPMExpressionAccess().getOperatorPlusMinusParserRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getPMExpressionAccess().getRightMDExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PMExpression returns PMParenthesis
	 *     PMExpression.PMExpression_1_0 returns PMParenthesis
	 *     MDExpression returns PMParenthesis
	 *     MDExpression.MDExpression_1_0 returns PMParenthesis
	 *     PowExpression returns PMParenthesis
	 *     PowExpression.PowExpression_1_0 returns PMParenthesis
	 *     Primary returns PMParenthesis
	 *     PMParenthesis returns PMParenthesis
	 *
	 * Constraint:
	 *     (expression=PMExpression | expression=External)
	 */
	protected void sequence_PMParenthesis(ISerializationContext context, PMParenthesis semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PlusMinus returns Minus
	 *
	 * Constraint:
	 *     {Minus}
	 */
	protected void sequence_PlusMinus(ISerializationContext context, Minus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PlusMinus returns Plus
	 *
	 * Constraint:
	 *     {Plus}
	 */
	protected void sequence_PlusMinus(ISerializationContext context, Plus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PMExpression returns Positive
	 *     PMExpression.PMExpression_1_0 returns Positive
	 *     MDExpression returns Positive
	 *     MDExpression.MDExpression_1_0 returns Positive
	 *     PowExpression returns Positive
	 *     PowExpression.PowExpression_1_0 returns Positive
	 *     Primary returns Positive
	 *     Number returns Positive
	 *     Positive returns Positive
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Positive(ISerializationContext context, Positive semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MathinterpreterPackage.Literals.NUMBER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathinterpreterPackage.Literals.NUMBER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPositiveAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PMExpression returns PowExpression
	 *     PMExpression.PMExpression_1_0 returns PowExpression
	 *     MDExpression returns PowExpression
	 *     MDExpression.MDExpression_1_0 returns PowExpression
	 *     PowExpression returns PowExpression
	 *     PowExpression.PowExpression_1_0 returns PowExpression
	 *
	 * Constraint:
	 *     (left=PowExpression_PowExpression_1_0 operator=Power right=Primary)
	 */
	protected void sequence_PowExpression(ISerializationContext context, PowExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MathinterpreterPackage.Literals.PM_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathinterpreterPackage.Literals.PM_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MathinterpreterPackage.Literals.PM_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathinterpreterPackage.Literals.PM_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, MathinterpreterPackage.Literals.PM_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathinterpreterPackage.Literals.PM_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowExpressionAccess().getPowExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPowExpressionAccess().getOperatorPowerParserRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getPowExpressionAccess().getRightPrimaryParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Power returns Pow
	 *
	 * Constraint:
	 *     {Pow}
	 */
	protected void sequence_Power(ISerializationContext context, Pow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PMExpression returns VariableName
	 *     PMExpression.PMExpression_1_0 returns VariableName
	 *     MDExpression returns VariableName
	 *     MDExpression.MDExpression_1_0 returns VariableName
	 *     PowExpression returns VariableName
	 *     PowExpression.PowExpression_1_0 returns VariableName
	 *     Primary returns VariableName
	 *     VariableName returns VariableName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_VariableName(ISerializationContext context, VariableName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MathinterpreterPackage.Literals.VARIABLE_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MathinterpreterPackage.Literals.VARIABLE_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (name=ID (expression=PMExpression | expression=External))
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
