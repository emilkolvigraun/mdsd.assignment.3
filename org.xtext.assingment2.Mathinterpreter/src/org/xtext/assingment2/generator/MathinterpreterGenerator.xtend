/*
 * generated by Xtext 2.21.0
 */
package org.xtext.assingment2.generator

import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.assingment2.mathinterpreter.MathExpression
import org.xtext.assingment2.mathinterpreter.DefineExpr
import org.xtext.assingment2.mathinterpreter.Function
import org.xtext.assingment2.mathinterpreter.PMExpression
import org.xtext.assingment2.mathinterpreter.MDExpression
import org.xtext.assingment2.mathinterpreter.Variable
import org.xtext.assingment2.mathinterpreter.Plus
import org.xtext.assingment2.mathinterpreter.Minus
import org.xtext.assingment2.mathinterpreter.Divide
import org.xtext.assingment2.mathinterpreter.Multiply
import org.xtext.assingment2.mathinterpreter.Primary
import org.xtext.assingment2.mathinterpreter.DefParenthesis
import org.xtext.assingment2.mathinterpreter.VariableName
import org.xtext.assingment2.mathinterpreter.PMParenthesis
import org.xtext.assingment2.mathinterpreter.Number
import java.util.List
import java.util.ArrayList
import org.xtext.assingment2.mathinterpreter.PowExpression
import org.xtext.assingment2.mathinterpreter.External

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathinterpreterGenerator extends AbstractGenerator {
	
	List<String> initVars
	List<Variable> letVars
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		initVars = new ArrayList<String>()
		letVars = new ArrayList<Variable>()
		
		val expressions = resource.allContents.toIterable.filter(MathExpression)
		
		fsa.generateFile("src/main/Main.java", 
			expressions.compile(resource.allContents.toIterable.filter(External)))
	}
	
	def dispatch String compile(Iterable<MathExpression> math, Iterable<External> externals)
		'''
		package main;
		
		import java.lang.Math;
		
		public class Main {	
			
			public static void main(String args[]) {
				new MathComputation().compute();
			}
		}
		
		class MathComputation {
			
			private Externals externals;
			
			public static interface Externals {
				«FOR ext : externals»
				public int «ext.name»(«var i = 0»«FOR arg : ext.arguments»int x«i++»«IF ext.arguments.indexOf(arg) < ext.arguments.length-1», «ENDIF»«ENDFOR»);
				«ENDFOR»
			}
			
			public MathComputation(Externals _externals) {
		   		externals = _externals;
			}
					
			public void compute() {
				«FOR expression : math»
				«expression.compile»
				«ENDFOR»
			}
		}
		'''	
	
	def List<String> getLetVarNames(){
		var _r = new ArrayList<String>()
		for (Variable variable : letVars) _r.add(variable.name)
		_r
	}
	
	def boolean letVarsContain(List<String> input){
		val letvarnames = getLetVarNames()
	    for (String str : input)
	    	if (!letvarnames.contains(str)) return false
	    true
	}
	
	def String define(Variable variable){
		var compiled = variable.compile
		'''
		«compiled»
		System.out.println("defined «compiled.substring(0, compiled.length-1).replace("int ", "")»");'''
	}
	
	def dispatch String compile(Function func){
		'''System.out.println("«func.description» -> «func.expression.compile()»" + " = " + («func.expression.compile()»));
		
		'''
	} 
	
	def dispatch String compile(DefineExpr func){
		var rString = ''''''
		
		val expression = func.expression.compile
		
		if (expression.contains("System.out.println")) {
			letVars.clear()
			return expression
		}	
		val names = getLetVarNames()
		
		for (Variable variable : func.variables) 
			if (names.contains(variable.name)) 
				letVars.set(names.indexOf(variable.name), variable)
			else letVars.add(variable)
			
		val variableNames = expression.replaceAll("\\s+","").replaceAll("\\d","").split("[-+*/]")
		if (variableNames.letVarsContain) {
			rString = '''
			«FOR variable : letVars»
			«IF variableNames.contains(variable.name)»
			«variable.define»
			«ENDIF»
			«ENDFOR»
			System.out.println("«expression»" + " = " + («expression»));
			
			'''
			
			letVars.clear() 
			return rString
		}
		
		rString
	}
	
	def dispatch String compile(External external){
		external.name
		var args = ""
		for (Number argument : external.arguments) {
			args += argument.value + ", "
		}
		'''externals.«external.name»(«args.substring(0, args.length-2)»)'''
	}
	
	def dispatch String compile(PMExpression expression){
		val left = expression.left.compile
		switch expression.operator {
			Plus: '''«left» + «expression.right.compile»'''
			Minus: '''«left» - «expression.right.compile»'''
		}
	}
	
	def dispatch String compile(MDExpression expression){
		val left = expression.left.compile
		switch expression.operator {
			Multiply: '''«left» * «expression.right.compile»'''
			Divide: '''«left» / «expression.right.compile»'''
		}
	}
	
	def dispatch String compile(PowExpression expression){
		'''Math.pow(«expression.left.compile», «expression.right.compile»)'''
	}
	
	def dispatch String compile(Primary primary) {primary.compile}
	def dispatch String compile(Number number) '''«number.value»'''
	def dispatch String compile(DefParenthesis definition) '''«definition»'''
	def dispatch String compile(VariableName name) '''«name.name»'''
	def dispatch String compile(PMParenthesis parenthesis) '''(«parenthesis.expression.compile»)'''
	
	def dispatch String compile(Variable variable) {
		if (initVars.contains(variable.name))
			'''«variable.name» = «variable.expression.compile»;'''
		else {
			initVars.add(variable.name)
			'''int «variable.name» = «variable.expression.compile»;'''
		}
	}
	
}
