/*
 * generated by Xtext 2.21.0
 */
package org.xtext.assingment2.generator

import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.assingment2.mathinterpreter.MathExpression
import org.xtext.assingment2.mathinterpreter.DefineExpr
import org.xtext.assingment2.mathinterpreter.Function
import org.xtext.assingment2.mathinterpreter.PMExpression
import org.xtext.assingment2.mathinterpreter.MDExpression
import org.xtext.assingment2.mathinterpreter.Variable
import org.xtext.assingment2.mathinterpreter.Plus
import org.xtext.assingment2.mathinterpreter.Minus
import org.xtext.assingment2.mathinterpreter.Divide
import org.xtext.assingment2.mathinterpreter.Multiply
import org.xtext.assingment2.mathinterpreter.Primary
import org.xtext.assingment2.mathinterpreter.DefParenthesis
import org.xtext.assingment2.mathinterpreter.VariableName
import org.xtext.assingment2.mathinterpreter.PMParenthesis
import org.xtext.assingment2.mathinterpreter.Number
import java.util.List
import java.util.ArrayList
import org.xtext.assingment2.mathinterpreter.PowExpression
import org.xtext.assingment2.mathinterpreter.External

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathinterpreterGenerator extends AbstractGenerator {
	
	List<String> initVars
	List<Variable> letVars
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		initVars = new ArrayList<String>()
		letVars = new ArrayList<Variable>()
		
		val expressions = resource.allContents.toIterable.filter(MathExpression)
		
		fsa.generateFile("src/main/Main.java", 
			expressions.compile(resource.allContents.toIterable.filter(External)))
	}
	
	def dispatch String compile(Iterable<MathExpression> math, Iterable<External> externals)
		'''
		package main;
		
		import java.lang.Math;
		
		public class Main {	
			
			public static void main(String args[]) {
				/* implement Externals */
				// new MathComputation( ... ).compute();
			}
		}
		
		class MathComputation {
			
			private Externals externals;
			
			public static interface Externals {
				«FOR ext : externals»
				public int «ext.name»(«var i = 0»«FOR arg : ext.arguments»int x«i++»«IF ext.arguments.indexOf(arg) < ext.arguments.length-1», «ENDIF»«ENDFOR»);
				«ENDFOR»
			}
			
			public MathComputation(Externals _externals) {
		   		externals = _externals;
			}
					
			public void compute() {
				«FOR expression : math»
				«expression.compile»
				«ENDFOR»
			}
		}
		'''	
	
	def List<String> getLetVarNames(){
		var _r = new ArrayList<String>()
		for (Variable variable : letVars) _r.add(variable.name.replaceAll("\\s+",""))
		_r
	}
	
	def boolean letVarsContain(List<String> input){
		val letvarnames = getLetVarNames()
	    for (String str : input) if (!letvarnames.contains(str)) return false 
	    true
	}
	
	def String define(Variable variable){
		var compiled = variable.compile
		'''
		«compiled»
		System.out.println("defined «compiled.substring(0, compiled.length-1).replace("int ", "")»");'''
	}
	
	def dispatch String compile(Function func){
		'''System.out.println("«func.description» -> «func.expression.compile()»" + " = " + («func.expression.compile()»));
		
		'''
	} 
	
	def dispatch String compile(DefineExpr func){
		var variables = func.variables
		var expression = func.expression
		while (expression instanceof DefineExpr) {
			variables.addAll(expression.variables)
			expression = expression.expression
		}
		if (variables.size() > 0) {
			return '''
			«FOR variable : variables»
			«variable.define»
			«ENDFOR»
			System.out.println("«func.description» -> «expression.compile»" + " = " + («expression.compile»));
			
			'''
		}
		''''''
	}
	
	def dispatch String compile(External external){
		external.name
		var args = ""
		for (i : 0 ..< external.arguments.length) {
		    val current = external.arguments.get(i)
		    switch (current) {
		    	Number: args += current.value + ", "
		    	VariableName: args += current.name + ", "
		    }
		}
		'''externals.«external.name»(«args.substring(0, args.length-2)»)'''
	}
	
	def dispatch String compile(PMExpression expression){
		val left = expression.left.compile
		switch expression.operator {
			Plus: '''«left» + «expression.right.compile»'''
			Minus: '''«left» - «expression.right.compile»'''
		}
	}
	
	def dispatch String compile(MDExpression expression){
		val left = expression.left.compile
		switch expression.operator {
			Multiply: '''«left» * «expression.right.compile»'''
			Divide: '''«left» / «expression.right.compile»'''
		}
	}
	
	def dispatch String compile(PowExpression expression){
		'''(int) Math.pow(«expression.left.compile», «expression.right.compile»)'''
	}
	
	def dispatch String compile(Primary primary) {primary.compile}
	def dispatch String compile(Number number) '''«number.value»'''
	def dispatch String compile(DefParenthesis definition) '''«definition»'''
	def dispatch String compile(VariableName name) '''«name.name»'''
	def dispatch String compile(PMParenthesis parenthesis) '''(«parenthesis.expression.compile»)'''
	
	def dispatch String compile(Variable variable) {
		if (initVars.contains(variable.name))
			'''«variable.name» = «variable.expression.compile»;'''
		else {
			initVars.add(variable.name)
			'''int «variable.name» = «variable.expression.compile»;'''
		}
	}
	
}
